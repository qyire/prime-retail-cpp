# PrimeRetail: High-Performance SKU Filtering\n\nA web application demonstrating a novel, high-performance retail product filtering system using C++, WebAssembly (WASM), and JavaScript. The core idea leverages Square-Free Integer (SFI) encoding for efficient client-side filtering.\n\n## Concept\n\nProduct attributes (like color, size, material) are mapped to unique prime numbers. A product's SKU is represented by a two-tier SFI code: `[master_sfi, local_sfi]`.\n\n*   **Master SFI:** Product of primes for globally shared attributes (e.g., color).\n*   **Local SFI:** Product of primes for attributes specific to a sub-graph or category (e.g., size and material within apparel).\n\nFiltering is achieved by calculating query SFIs based on selected attributes and performing fast divisibility checks (`product_sfi % query_sfi == 0`) against the product database directly in the user's browser via WASM.\n\n**Benefits:**\n\n*   **Low Latency:** Filtering logic runs client-side, reducing server load and network latency.\n*   **Traceability:** The prime factors inherently provide an audit trail for why a product matched a filter.\n\n## Architecture (MVP)\n\n```\n+-----------------+      +------------------+      +----------------+\n| C++ (PrimeKit)  |----->| Emscripten/CMake |----->| WASM + JS Glue |\n| - SFI Logic     |      | - Compile & Bind |      | (primekit.wasm)|\n| - Filtering     |      +------------------+      | (primekit.js)  |\n+-----------------+                                +--------+-------+\n                                                         |\n                                                         v\n+-----------------+      +--------------------+      +---------v------+\n| HTML/CSS        |<-----| JS (main.js)       |<-----| Browser        |\n| - UI Controls   |      | - Load Data/WASM   |      | - Runs WASM    |\n| - Display       |      | - Calc Query SFIs  |      | - Renders UI   |\n+-----------------+      | - Call WASM Filter |      +----------------+\n                       | - Update UI        |\n                       +--------------------+\n```\n\n*(Future goal: Integrate WebGPU for optimized rendering of large result sets)*\n\n## Tech Stack\n\n*   **Core Logic:** C++ (C++17)\n*   **Compilation:** Emscripten, CMake\n*   **Client-Side Runtime:** WebAssembly (WASM)\n*   **Frontend:** JavaScript (ES Modules), HTML5, CSS3\n*   **(Future):** WebGPU, WGSL\n\n## Core Features (MVP)\n\n*   Hardcoded prime mappings for master (color) and local (size, material) attributes.\n*   JavaScript logic to load inventory JSON and pre-calculate Master/Local SFIs for each item.\n*   C++ `PrimeKit` class compiled to WASM:\n    *   Receives pre-calculated `SkuData` (ID, master SFI, local SFI) from JavaScript.\n    *   `perform_filter` method takes `master_query` and `local_query` SFIs.\n    *   Performs efficient two-tier divisibility filtering.\n    *   Returns a list of matching SKU IDs.\n*   Basic HTML interface with dropdowns to select filter attributes.\n*   JavaScript interaction to calculate query SFIs, call WASM, and display results.\n\n## How to Build\n\n1.  **Prerequisites:**\n    *   Install [CMake](https://cmake.org/download/).\n    *   Install the [Emscripten SDK](https://emscripten.org/docs/getting_started/downloads.html). Make sure its environment is activated (e.g., by running `source ./emsdk_env.sh` in the SDK directory).\n2.  **Configure using CMake:**\n    *   Navigate to the `prime-retail-cpp` project root directory.\n    *   Create a build directory: `mkdir build && cd build`\n    *   Run CMake with the Emscripten toolchain file (replace `<path-to-emsdk>`):\n        ```bash\n        # On Linux/macOS\n        emcmake cmake .. -DCMAKE_BUILD_TYPE=Release \n        \n        # On Windows (using Ninja, adjust generator if needed)\n        # You might need to specify the toolchain file explicitly if emcmake doesn\'t work\n        # cmake .. -G Ninja -DCMAKE_TOOLCHAIN_FILE=<path-to-emsdk>/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake -DCMAKE_BUILD_TYPE=Release\n        ```\n3.  **Build the WASM module:**\n    *   Inside the `build` directory, run the build command:\n        ```bash\n        # On Linux/macOS (if using Makefiles, default)\n        make\n        \n        # Or if using Ninja\n        # ninja \n        ```\n    *   This will generate `primekit.wasm` and `primekit.js` inside a `wasm_build` directory within the `build` directory (e.g., `build/wasm_build/`).\n\n## How to Run\n\n1.  **Build Output:** Ensure the `primekit.wasm` and `primekit.js` files exist in `prime-retail-cpp/build/wasm_build/`.\n2.  **Copy Build Files:** The `index.html` expects the WASM files to be accessible relative to the JavaScript file. The simplest way is often to copy the contents of `build/wasm_build/` into the main project\'s `wasm_build/` directory:\n    ```bash\n    # From the project root (prime-retail-cpp/)\n    cp build/wasm_build/* wasm_build/\n    ```\n    *(Alternatively, adjust the import path in `src/js/main.js` or serve files differently)*\n3.  **Serve Files:** Run a simple local HTTP server from the *project root directory* (`prime-retail-cpp/`) because the JS/HTML files need access to both `static/` and `wasm_build/` (and potentially `data/`).\n    ```bash\n    # Make sure you are in the prime-retail-cpp directory\n    python -m http.server\n    # Or if you have Node.js/npm:\n    # npx serve .\n    ```\n4.  **Open Browser:** Navigate to `http://localhost:8000/static/index.html` (or the port provided by your server).\n5.  Interact with the filter dropdowns and click \"Apply Filters\". Check the browser console and the WASM output area for messages.\n\n## Traceability Benefit\n\nThe SFI encoding allows for easy traceability. If a product with `master_sfi=6` (primes 2\*3) matches a query for `master_query=2`, we know it matched because of the attribute associated with prime 2 (e.g., 'red'). This provides a clear audit trail directly from the filter results.\n\n## Future Work\n\n*   **WebGPU Rendering:** Visualize large product sets efficiently using WebGPU shaders.\n*   **Dynamic Data Loading:** Load prime definitions and inventory from external sources/APIs instead of hardcoding/static JSON.\n*   **Improved UI/UX:** More sophisticated filter controls and result presentation.\n*   **Error Handling:** More robust error handling for WASM loading, data fetching, and SFI overflows.\n*   **Complex Queries:** Support for OR conditions or range-based filtering (might require different encoding approaches).\n*   **Benchmarking:** Detailed performance analysis compared to traditional filtering methods.\n\n## Code Comments\n\nKey functions, logic, and build steps in C++, JavaScript, and CMakeLists.txt include comments explaining their purpose. 